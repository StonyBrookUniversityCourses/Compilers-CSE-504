%{
#include <iostream>
extern int yylex();
extern void yyerror(const char *s);
extern void errMsg(const char *s);
#define prt(x) cout << x << endl;
using namespace std;
%}

%union{
   char* cVal;
   unsigned int uVal;
   double dblVal;
};

/* Operators */

%token TOK_LEX_ERROR TOK_PAT_STAR TOK_PAT_OR TOK_PAT_NOT
%token TOK_PLUS TOK_MINUS TOK_UMINUS TOK_MULT TOK_DIV TOK_MOD 
%token TOK_BITAND TOK_BITOR TOK_BITNOT TOK_BITXOR TOK_SHL TOK_SHR 
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE TOK_AND TOK_OR TOK_NOT 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN TOK_DOT

/* Key words */

%token 		TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token 		TOK_ULONGNUM TOK_UINTNUM TOK_DOUBLENUM 
%token 		TOK_VOID TOK_STRING TOK_LONG 
%token 		TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token<cVal> 	TOK_STRCONST TOK_TRUE TOK_FALSE TOK_IDENT

%type<cVal> error
/*********************   Precedence and Associativity    ********************/
%nonassoc	TOK_ASSIGN
%left		TOK_PAT_OR
%left		TOK_COLON
%left		TOK_PAT_STAR
%right		TOK_PAT_NOT
%left		TOK_OR
%left		TOK_AND
%right		TOK_NOT
%nonassoc	TOK_EQ TOK_NE TOK_GT TOK_LT TOK_GE TOK_LE
%left 		TOK_BITOR TOK_BITXOR
%left		TOK_BITAND
%right		TOK_BITNOT
%left		TOK_SHL TOK_SHR
%left		TOK_PLUS TOK_MINUS
%left		TOK_MULT TOK_DIV TOK_MOD
%right 		TOK_UMINUS
/*%left		where is left brac*/
%left		TOK_DOT
/**************************************************************************/

%start specification
%%

specification: ifc_decl_star rule_star {prt("Spec");}
| /*empty string*/ {	
	errMsg("Must contain at least one rule");
	prt("Spec");
};

ifc_decl_star: /* empty */ {
}
| ifc_decl_star ifc_decl {}
| ifc_decl_star error TOK_SEMICOLON {
	errMsg("Syntax error, expecting a declaration");
	printf ("Error: %s\n", $2);	
};

ifc_decl: var_dec 
| event_dec_star 
| class_dec 
| func_decl_star
| TOK_SEMICOLON /* Fill in the other rules */
;

rule_star: rule
| rule_star rule
;

rule : evn_pat_star TOK_ARROW statement_star {
	prt("Rule");
};


event_dec_star: event_dec {
	prt("EventDecl");
};

event_dec : TOK_EVENT event_name TOK_LPAREN formal_param_list_star TOK_RPAREN TOK_SEMICOLON
;

class_dec: TOK_CLASS class_name TOK_SEMICOLON {
	prt("ClassDecl");
};

func_decl_star: func_decl TOK_SEMICOLON | func_decl func_body{
};

func_decl : type_star func_name TOK_LPAREN formal_param_list_star TOK_RPAREN{
	prt("FunctionDecl");
};

func_body: TOK_LBRACE func_body_inner TOK_RBRACE {
	prt("FunctionBody");
};

func_body_inner: statement_star
| func_body_inner statement_star
| var_dec statement_star 
;

formal_param_list_star : /*empty*/
| formal_param_list {
	prt("FormalParamList");
};

statement_star: statement 
| statement_star TOK_SEMICOLON
;

com_stmt_star: com_stmt {
	prt("CompoundStmt");
};


com_stmt: TOK_LBRACE stmt_list TOK_RBRACE {
};

stmt_list: statement_star 
| stmt_list statement_star
;


statement : empty_stmt
| func_invoc_stmt
| com_stmt_star
| assign_expr TOK_SEMICOLON {prt("AssignStmt");}

;

empty_stmt: /*empty statement*/ TOK_SEMICOLON
;

func_invoc_stmt: func_invoc TOK_SEMICOLON {
	prt("FunctionInvocationStmt");
};

func_invoc: func_name TOK_LPAREN expr_list_star TOK_RPAREN {
	prt("FunctionInvocation");
};

expr_list_star: expr_list 
;

expr_list: /*empty*/
| expr_star
| expr_list TOK_COMMA expr_star
;

var_dec: type_star var_list TOK_SEMICOLON
;

var_list: var_name {prt("VariableDecl");}
| var_assign
| var_list TOK_COMMA var_name{prt("VariableDecl");}
;

var_assign: var_name TOK_ASSIGN expr_star {
	prt("VariableDeclWithInit");
};

var_name: TOK_IDENT
;

ref_expr: var_name {
	prt("RefExpr");
};

expr_star: expr;

expr: lit_star
| func_invoc
| ref_expr
| assign_expr
;

assign_expr: ref_expr TOK_ASSIGN expr {
	prt("Assignment");
};


lit_star:literal {
	prt("Literal");
};

literal: numbers
| TOK_UMINUS numbers
| TOK_STRCONST
;

numbers: TOK_ULONGNUM
| TOK_UINTNUM 
| TOK_DOUBLENUM
;

formal_param_list :formal_param 
| formal_param_list TOK_COMMA formal_param
;

formal_param: type_star TOK_IDENT {
	prt("FormalParam");
};

evn_pat_star: evn_pat {
};

evn_pat : primitive_pat_star | evn_negation evn_pat 

evn_negation: TOK_NOT 
| TOK_COLON 
| TOK_PAT_OR 
| TOK_MULT TOK_MULT
;

primitive_pat_star: primitive_pat {
	prt("PrimitivePat");
}
| primitive_pat TOK_BITOR expr_star {
	prt("PrimitivePatWithCond");
};

primitive_pat : normal_event
| any_event_star
;

normal_event: event_name TOK_LPAREN evn_param_list_star TOK_RPAREN {
	prt("NormalEvent");
};
 /*support bit or condition*/

any_event_star: any_event {
	prt("anyEvent");
}

any_event: TOK_ANY | TOK_ANY TOK_LPAREN evn_param_list_star TOK_RPAREN
;

evn_param_list_star : evn_param_list
;

evn_param_list: /*empty*/
| event_param
| evn_param_list TOK_COMMA event_param
;

event_param: TOK_IDENT{
	prt("EventFormalParam");

};

func_name: TOK_IDENT;

class_name: TOK_IDENT;

event_name : TOK_IDENT;

type_star : type {
	prt("Type");
};



type: base_type
| TOK_UNSIGNED base_type
| class_name

base_type:TOK_VOID 
| TOK_STRING 
| TOK_INT 
| TOK_BOOL 
| TOK_BYTE 
| TOK_DOUBLE 
| TOK_SHORT
| TOK_LONG
;
%%

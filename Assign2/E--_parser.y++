%{
#include <iostream>
extern int yylex();
extern void yyerror(const char *s);
extern void errMsg(const char *s);
#define prt(x) cout << x << endl;
using namespace std;
%}

%union{
   char* cVal;
   unsigned int uVal;
   double dblVal;
};

/* Operators */

%token TOK_LEX_ERROR TOK_PAT_STAR TOK_PAT_OR TOK_PAT_NOT
%token TOK_PLUS TOK_MINUS TOK_UMINUS TOK_MULT TOK_DIV TOK_MOD 
%token TOK_BITAND TOK_BITOR TOK_BITNOT TOK_BITXOR TOK_SHL TOK_SHR 
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE TOK_AND TOK_OR TOK_NOT 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN

/* Key words */

%token TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token TOK_ULONGNUM TOK_UINTNUM TOK_DOUBLENUM TOK_VOID TOK_STRING TOK_LONG 
%token TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token<cVal> TOK_STRCONST TOK_TRUE TOK_FALSE TOK_IDENT

%type<cVal> error 
/*********************   Precedence and Associativity    ********************/


/**************************************************************************/

%start specification
%%

specification: ifc_decl_star rule_star {
	prt("Spec");
};

ifc_decl_star: /* empty */ {
}
| ifc_decl_star ifc_decl {}
| ifc_decl_star error TOK_SEMICOLON {
	errMsg("Syntax error, expecting a declaration");
 printf ("Error: %s\n", $2);	
};

ifc_decl: event_dec_star | class_dec | func_decl | TOK_SEMICOLON /* Fill in the other rules */
;

rule_star: rule {
	prt("Rule");
};


rule : evn_pat_star TOK_ARROW statement_star
;


event_dec_star: event_dec {
	prt("EventDecl");
};

event_dec : TOK_EVENT event_name TOK_LPAREN formal_param_list_star TOK_RPAREN TOK_SEMICOLON
;

class_dec: TOK_CLASS class_name TOK_SEMICOLON {
	prt("ClassDecl");
};

func_decl : type_star func_name TOK_LPAREN formal_param_list_star TOK_RPAREN TOK_SEMICOLON{
	prt("FunctionDecl");
};

formal_param_list_star : formal_param_list {
	prt("FormalParamList");
};

statement_star: statement {
	prt("Statement");
};

statement : /* fill in*/;

formal_param_list : /*empty*/
| formal_param 
| formal_param_list TOK_COMMA formal_param
;

formal_param: type_star TOK_IDENT {
	prt("FormalParam");
};

evn_pat_star: evn_pat {
	prt("NormalEvent");
}
evn_pat : primitive_pat_star | evn_negation evn_pat 

evn_negation: TOK_NOT 
| TOK_COLON 
| TOK_PAT_OR 
| TOK_MULT TOK_MULT
;

primitive_pat_star: primitive_pat {
	prt("PrimitivePat");
};

primitive_pat: event_name TOK_LPAREN evn_param_list_star TOK_RPAREN;
 /*support bit or condition*/

evn_param_list_star : evn_param_list
;

evn_param_list: /*empty*/
| event_param
| evn_param_list TOK_COMMA event_param
;

event_param: TOK_IDENT{
	prt("EventFormalParam");

};
func_name: TOK_IDENT;

class_name: TOK_IDENT;

event_name : TOK_IDENT;

type_star : type {
	prt("Type");
};



type: base_type
| TOK_UNSIGNED base_type
| class_name

base_type:TOK_VOID 
| TOK_STRING 
| TOK_INT 
| TOK_BOOL 
| TOK_BYTE 
| TOK_DOUBLE 
| TOK_SHORT
| TOK_LONG
;
%%
